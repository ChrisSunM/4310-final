<html>

<head>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    #map {
      fill: white;
    }

    #tooltip {
      position: absolute;
      padding: 2px;
      pointer-events: none;
      border-radius: 4px;
      box-shadow: 3px 3px 10px 0px rgba(0, 0, 0, 0.25);
      font: 15px sans-serif;
      color: #030303;
      line-height: 1;
      padding: 12px;
      background: rgb(250, 247, 247);
      color: rgb(19, 18, 18);
      border-radius: 2px;
    }
  </style>
</head>

<body>
  <h2>final project</h2>
  <div>
    <button id="button1">Early career pay</button>
    <button id="button2">Mid career pay</button>
  </div>
  </br>
  <svg id="map" height="800" width="1000" style="border:1px solid black;"> </svg>
  <div id="tooltip"></div>

</body>
<script>
  const map = d3.select("#map")
  const mapMargins = { t: 0, r: 0, b: 0, l: 0 }
  const mapWidth = 1000
  const mapHeight = 800
  const mapArea = map.append("g")
    .attr("transform", `translate(${mapMargins.l},${mapMargins.t})`)
  let render = async function () {
    let usMap = await d3.json("datasets/us-map.json")

    // Creating map
    let states = topojson.feature(usMap, usMap.objects.states);
    let statesMesh = topojson.mesh(usMap, usMap.objects.states);
    let projection = d3.geoAlbersUsa().fitSize([1000, 800], states);
    let path = d3.geoPath().projection(projection);
    let defs = map.append("defs");

    let linearGradient = defs.append("linearGradient")
      .attr("id", "linear-gradient");

    let legend = map.append("g")
      .attr("class", "legend")
      .attr("transform", "translate(" + (200) + "," + (750) + ")");

    legend.append("rect")
      .attr("width", 650)
      .attr("height", 20)
      .style("fill", "url(#linear-gradient)");

    mapArea.selectAll("path.state").data(states.features)
      .attr("class", "state")
      .join("path")
      .attr("d", path)
      .attr("stroke", "black")

    // Define the zoom function
    function zoomed(event) {
      mapArea.attr('transform', event.transform);
    }

    // Create a zoom behavior
    let zoom = d3.zoom()
      .scaleExtent([1, 10])
      .on('zoom', zoomed);

    // Create a brush behavior
    let brush = d3.brush()
      .extent([[0, 0], [mapWidth, mapHeight]])
      .on('brush end', brushed);

    // Add the brush to the map
    mapArea.append('g')
      .attr('class', 'brush')
      .call(brush);

    // Add the double click event listener to the map
    mapArea.on('dblclick', resetZoomAndBrush);

    // Define the resetZoomAndBrush function
    function resetZoomAndBrush() {
      // Transition the mapArea back to the original transform
      mapArea.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity);

      // Remove the brush selection
      map.select('.brush').call(brush.move, null);
    }



    //dataset with actual demographics + college names
    let colleges = await d3.csv("datasets/salary_potential.csv")
    console.log(colleges)
    //new dataset found, linked in second document
    let largeData = await d3.csv("datasets/hd2021.csv")
    console.log(largeData)

    //new dataset found, linked in third document
    let tuitions = await d3.csv("datasets/tuition_cost.csv")
    console.log('tuitions', tuitions)

    //dataset made from filtering and processing in jupyter notebook
    let finalcolleges = await d3.csv("datasets/filtered_colleges.csv")
    console.log(finalcolleges)
    // Use a map to link colleges and their associated data
    let collegeMap = new Map(colleges.map(d => [d.name, d]));
    let tuitionsMap = new Map(tuitions.map(d => [d.name, d]));

    finalcolleges.forEach(d => {
      d.Position = projection([d.LONGITUD, d.LATITUDE])
      let collegeInfo = collegeMap.get(d.INSTNM);
      let tuitionsInfo = tuitionsMap.get(d.INSTNM);
      if (collegeInfo) {
        d.early_career_pay = +collegeInfo.early_career_pay;
        d.mid_career_pay = +collegeInfo.mid_career_pay;
        d.state_name = collegeInfo.state_name;
        d.stem_percent = collegeInfo.stem_percent;
        if (tuitionsInfo != undefined) {
          d.tuition = +tuitionsInfo.in_state_tuition;
          d.type = tuitionsInfo.type;
        }

      }
    });

    // Now finalcolleges contains the merged data
    console.log(finalcolleges);
    // Custom interpolator function for red-orange-green gradient
    function redOrangeGreen(t) {
      return d3.interpolateRgb(
        d3.interpolateRgb("red", "orange")(t),
        "green"
      )(t);
    }

    // Create color scales
    let earlyCareerPayScale = d3.scaleSequential()
      .domain(d3.extent(finalcolleges, d => +d.early_career_pay))
      .interpolator(redOrangeGreen);

    let midCareerPayScale = d3.scaleSequential()
      .domain(d3.extent(finalcolleges, d => +d.mid_career_pay))
      .interpolator(redOrangeGreen);

    finalcolleges.forEach(d => {
      mapArea.selectAll("circle").data(finalcolleges)
        .join("circle")
        .attr("cx", d => {
          if (d.Position != null) {
            return d.Position[0]
          }
        })
        .attr("cy", d => {
          if (d.Position != null) {
            return d.Position[1]
          }
        })
        .attr("r", 5)
        .attr("fill", "gray")
        .on("mousemove", function (event, d) {
          d3.select(this).attr("stroke", "black").attr("stroke-width", "2px")
            .attr('r', 8)

          if (d.type != undefined) {
            var text = "<b>Name:</b> " + d.INSTNM +
              "<br/><b>State:</b> " + d.state_name +
              "<br/><b>Early Career Pay: </b> " + "$" + formatNumberWithCommas(d.early_career_pay) +
              "<br/><b>Mid Career Pay: </b> " + "$" + formatNumberWithCommas(d.mid_career_pay) +
              "<br/><b>STEM percent: </b>" + d.stem_percent +
              "%<br/><b>Tuition: </b>" + "$" + formatNumberWithCommas(d.tuition) +
              "<br/><b>Type:</b> " + d.type;
          } else {
            var text = "<b>Name:</b> " + d.INSTNM +
              "<br/><b>State:</b> " + d.state_name +
              "<br/><b>Early Career Pay:</b> " + "$" + formatNumberWithCommas(d.early_career_pay) +
              "<br/><b>Mid Career Pay:</b> " + "$" + formatNumberWithCommas(d.mid_career_pay) +
              "<br/><b>STEM percent:</b> " + d.stem_percent + "%" +
              "<br/><b>Tuition: </b>" + "$" + formatNumberWithCommas(d.tuition);
          }

          function formatNumberWithCommas(number) {
            return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
          }


          d3.select('#tooltip').html(text)
            .style('left', (event.pageX + 25) + 'px')
            .style('top', (event.pageY - 28) + 'px').style('opacity', 1);
        })
        .on('mouseleave', function () {
          d3.select(this).attr("stroke", "none").attr('r', 5)
          d3.select('#tooltip').style('opacity', 0)
        });
    })

    function brushed(event) {
      // If there is no selection, do nothing
      if (!event.selection) return;

      // Get the current zoom transform
      let currentZoom = d3.zoomTransform(mapArea.node());

      // Get the selection coordinates and adjust them based on the current zoom level
      let [[x0, y0], [x1, y1]] = event.selection;
      let [[tx0, ty0], [tx1, ty1]] = [[x0, y0], [x1, y1]].map(d => currentZoom.invert(d));

      // Calculate the new zoom parameters
      let dx = tx1 - tx0;
      let dy = ty1 - ty0;
      let x = (tx0 + tx1) / 2;
      let y = (ty0 + ty1) / 2;
      let scale = Math.max(1, Math.min(10, 0.9 / Math.max(dx / mapWidth, dy / mapHeight)));
      let translate = [mapWidth / 2 - scale * x, mapHeight / 2 - scale * y];

      // Apply the new zoom parameters
      mapArea.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }

    // Get references to the two buttons
    const button1 = document.getElementById("button1");
    const button2 = document.getElementById("button2");

    // Function to update the colors based on the button clicked
    function buttonClicked(button) {
      let colorScale;

      if (button === "Button 1") {
        colorScale = earlyCareerPayScale;
      } else if (button === "Button 2") {
        colorScale = midCareerPayScale;
      }

      // Update the circles' colors based on the selected color scale
      mapArea.selectAll("circle")
        .attr("fill", d => colorScale(d[button === "Button 1" ? 'early_career_pay' : 'mid_career_pay']));

      // Update the legend's gradient
      linearGradient.selectAll("stop").remove();
      linearGradient.selectAll("stop")
        .data(colorScale.ticks().map((t, i, n) => ({ offset: `${100 * i / n.length}%`, color: colorScale(t) })))
        .enter().append("stop")
        .attr("offset", d => d.offset)
        .attr("stop-color", d => d.color);

      // Update the legend's labels
      legend.selectAll("text").remove();
      legend.selectAll("text")
        .data(colorScale.ticks())
        .enter().append("text")
        .attr("x", (d, i, n) => `${650 * i / n.length}`)
        .attr("y", -5)
        .style('fill', 'black')
        .text(d => d);

      // Add tick lines
      legend.selectAll("line").remove();
      legend.selectAll("line")
        .data(colorScale.ticks())
        .enter().append("line")
        .attr("x1", (d, i, n) => `${650 * i / n.length}`)
        .attr("x2", (d, i, n) => `${650 * i / n.length}`)
        .attr("y1", 0)
        .attr("y2", 6)
        .style("stroke", "black");
    }

    // Add a click event listener to each button
    button1.addEventListener("click", function () {
      buttonClicked("Button 1");
    });

    button2.addEventListener("click", function () {
      buttonClicked("Button 2");
    });
  }
  render();
</script>

</html>